
OOPs concepts in Java
---------------------

Object-oriented programming System(OOPs) is a programming paradigm based on the concept of 
“objects” that contain data and methods.

The primary purpose of object-oriented programming is to increase the flexibility and 
maintainability of programs.

Object oriented programming brings together data and its behaviour(methods) in a single 
location(object) makes it easier to understand how a program works.

We will cover each and every feature of OOPs in detail so that you won’t face any difficultly 
understanding OOPs Concepts.


OOPs Concepts – Table of Contents

1.What is an Object
2.What is a class
3.Constructor in Java
4.Object Oriented Programming Features
    Abstraction
    Encapsulation
    Inheritance
    Polymorphism
5.Abstract Class and Methods
6.Interfaces in Java


What is an Object

|------------------| instance of  |-----------|
|     OBJECT       | ========>>   |  Class    | 
|------------------|              |-----------|  


Object: is a bundle of data and its behaviour(often known as methods).

Objects have two characteristics: They have states and behaviors.

Examples of states and behaviors
Example 1:
Object: House
State: Address, Color, Area
Behavior: Open door, close door


So if I had to write a class based on states and behaviours of House.

I can do it like this: States can be represented as instance variables and behaviours as 
methods of the class. We will see how to create classes in the next section of this guide.

class House {
   String address;
   String color;
   double area;

   void openDoor() {
      //Write code here
   }

   void closeDoor() {
      // Write code here
   }
 ...
 ...
}


Example 2:

Let’s take another example.

Object: Car
State: Color, Brand, Weight, Model
Behavior: Break, Accelerate, Slow Down, Gear change.

Note: As we have seen above, the states and behaviors of an object, can be represented by 
variables and methods in the class respectively.

Characteristics of Objects:

If you find, it's hard to understand Abstraction and Encapsulation, do not worry as I have 
covered these topics in detail with examples in the next section of this guide.


Abstraction
Encapsulation
Message passing


Abstraction: Abstraction is a process where you show only “relevant” data and “hide” 
unnecessary details of an object from the user.

Encapsulation: Encapsulation simply means binding object with state(fields) and 
behaviour(methods) together. If you are creating class, you are doing encapsulation.

Message passing
A single object by itself may not be very useful. An application contains many objects. 
One object interacts with another object by invoking methods on that object. 
It is also referred to as Method Invocation. See the diagram below.
            _____________
            |  ObjectA  |                    
            | ________  |
            | |Methods| |
            | | Data  | | 
            | |______ | |
            |___________| 
                  |
                  | Message
                  |
            ______|_______
            |  ObjectA  |
            | ________  |
            | |Methods| |
            | | Data  | | 
            | |______ | |
            |___________| 
 
What is a Class in OOPs Concepts

A class can be considered as a blueprint using which you can create as many objects as you like.
For example, here we have a class Website that has two data members (also known as fields, 
instance variables and object states). This is just a blueprint, it does not represent any 
website, however using this we can create Website objects (or instances) that represents the 
websites. We have created two objects, while creating objects we provided separate properties 
to the objects using constructor.


public class Website {
   //fields (or instance variable)
   String webName;
   int webAge;

   // constructor
   Website(String name, int age){
      this.webName = name;
      this.webAge = age;
   }
   public static void main(String args[]){
      // Creating objects
      Website obj1 = new Website("beginnersbook", 5);
      Website obj2 = new Website("google", 18);

     // Accessing object data through reference
     System.out.println(obj1.webName+" "+obj1.webAge);
     System.out.println(obj2.webName+" "+obj2.webAge);
   }
}

Output:
beginnersbook 5
google 18


What is a Constructor
Constructor looks like a method but it is in fact not a method. It’s name is same as class 
name and it does not return any value. You must have seen this statement in almost all the 
programs I have shared above:

MyClass obj = new MyClass();
If you look at the right side of this statement, we are calling the default constructor of 
class myClass to create a new object (or instance).

We can also have parameters in the constructor, such constructors are known as parametrized constructors.

Example of constructor

public class ConstructorExample {
   int age;
   String name;
	
   // Default constructor
   ConstructorExample(){
	this.name="Chaitanya";
	this.age=30;
   }
	
   // Parameterized constructor
   ConstructorExample(String n,int a){
	this.name=n;
	this.age=a;
   }
   
   public static void main(String args[]){
	ConstructorExample obj1 = new ConstructorExample();
	ConstructorExample obj2 = new ConstructorExample("Steve", 56);
	System.out.println(obj1.name+" "+obj1.age);
	System.out.println(obj2.name+" "+obj2.age);
   }
}

Output:
Chaitanya 30
Steve 56


Object Oriented Programming features:

-----------------------------------------------------------------------
       Abstraction                               Encapsulation
               \                                  /
                ObjectOrientedProgrammingFeatures
                /                                \
       Inheritance                               Polymorphism
-----------------------------------------------------------------------


These four features are the main OOPs Concepts that you must learn to understand the Object 
Oriented Programming in Java.

1.Abstraction
-----------
Abstraction is a process where you show only “relevant” data and “hide” unnecessary details 
of an object from the user. For example, when you login to your bank account online, you 
enter your user_id and password and press login, what happens when you press login, how the 
input data sent to server, how it gets verified is all abstracted away from the you. Read 
more about it here: Abstraction in Java.

2.Encapsulation
---------------
Encapsulation simply means binding object with state(fields) and behavior(methods) together. 
If you are creating class, you are doing encapsulation.


Encapsulation example in Java
How to
1) Make the instance variables private so that they cannot be accessed directly from outside 
the class. You can only set and get values of these variables through the methods of the class.
2) Have getter and setter methods in the class to set and get the values of the fields.


class EmployeeCount {
   
   private int numOfEmployees = 0;
   public void setNoOfEmployees (int count)
   {
       numOfEmployees = count;
   }
   public double getNoOfEmployees () 
   {
       return numOfEmployees;
   }
}


public class EncapsulationExample
{
   public static void main(String args[])
   {
      EmployeeCount obj = new EmployeeCount ();
      obj.setNoOfEmployees(5613);
      System.out.println("No Of Employees: "+(int)obj.getNoOfEmployees());
    }
}

Output:
No Of Employees: 5613

The class EncapsulationExample that is using the Object of class EmployeeCount will not able 
to get the NoOfEmployees directly. It has to use the setter and getter methods of the same 
class to set and get the value.
So what is the benefit of encapsulation in java programming
Well, at some point of time, if you want to change the implementation details of the class 
EmployeeCount, you can freely do so without affecting the classes that are using it.

3.Inheritance
------------
The process by which one class acquires the properties and functionalities of another class 
is called inheritance. 

Inheritance provides the idea of reusability of code and each sub class defines only those 
features that are unique to it, rest of the features can be inherited from the parent class.


Inheritance is a process of defining a new class based on an existing class by extending its 
common data members and methods.
Inheritance allows us to reuse of code, it improves reusability in your java application.
The parent class is called the base class or super class. The child class that extends the 
base class is called the derived class or sub class or child class.

Note: The biggest advantage of Inheritance is that the code in base class need not be 
rewritten in the child class.

The variables and methods of the base class can be used in the child class as well.

Syntax: Inheritance in Java
To inherit a class we use extends keyword. Here class A is child class and class B is parent class.

class A extends B
{

}

Inheritance Example

In this example, we have a parent class Teacher and a child class MathTeacher. 
In the MathTeacher class we need not to write the same code which is already present in the 
present class. Here we have college name, designation and does() method that is common for 
all the teachers, thus MathTeacher class does not need to write this code, the common data 
members and methods can inherited from the Teacher class.


class Teacher {
   String designation = "Teacher";
   String college = "Beginnersbook";
   void does(){
	System.out.println("Teaching");
   }
}

public class MathTeacher extends Teacher {
   String mainSubject = "Maths";
   public static void main(String args[]){
      MathTeacher obj = new MathTeacher();
      System.out.println(obj.college);
      System.out.println(obj.designation);
      System.out.println(obj.mainSubject);
      obj.does();
   }
}


Output:
Beginnersbook
Teacher
Maths
Teaching


Note: Multi-level inheritance is allowed in Java but not multiple inheritance


----------------
college staff
---------------
     ^
     |
----------------
  Teacher                 /
---------------     |   /
     ^              | /
     |
----------------
Math Teacher
---------------


Types of Inheritance:
--------------------

Single Inheritance: refers to a child and parent class relationship where a class extends the
another class.

Multilevel inheritance: refers to a child and parent class relationship where a class extends
the child class. For example class A extends class B and class B extends class C.

Hierarchical inheritance: refers to a child and parent class relationship where more than one
classes extends the same class. For example, class B extends class A and class C extends 
class A.

Multiple Inheritance: refers to the concept of one class extending more than one classes, 
which means a child class has two parent classes. Java doesn’t support multiple inheritance, 
read more about it here.

Most of the new OO languages like Small Talk, Java, C# do not support Multiple inheritance. 
Multiple Inheritance is supported in C++.


Polymorphism
-------------
Polymorphism is a object oriented programming feature that allows us to perform a single 
action in different ways. For example, lets say we have a class Animal that has a method 
animalSound(), here we cannot give implementation to this method as we do not know which 
Animal class would extend Animal class. So, we make this method abstract like this:


public abstract class Animal{
   ...
   public abstract void animalSound();
}
Now suppose we have two Animal classes Dog and Lion that extends Animal class. We can provide
the implementation detail there.

public class Lion extends Animal{
...
    @Override
    public void animalSound(){
        System.out.println("Roar");
    }
}
and

public class Dog extends Animal{
...
    @Override
    public void animalSound(){
        System.out.println("Woof");
    }
}
As you can see that although we had the common action for all subclasses animalSound() but 
there were different ways to do the same action. This is a perfect example of polymorphism 
(feature that allows us to perform a single action in different ways).


Types of Polymorphism
---------------------
1) Static Polymorphism
2) Dynamic Polymorphism


Static Polymorphism:

Polymorphism that is resolved during compiler time is known as static polymorphism. Method 
overloading can be considered as static polymorphism example.
Method Overloading: This allows us to have more than one methods with same name in a class 
that differs in signature.


class DisplayOverloading
{
    public void disp(char c)
    {
         System.out.println(c);
    }
    public void disp(char c, int num)  
    {
         System.out.println(c + " "+num);
    }
}
public class ExampleOverloading
{
   public static void main(String args[])
   {
       DisplayOverloading obj = new DisplayOverloading();
       obj.disp('a');
       obj.disp('a',10);
   }
}

Output:
a
a 10

When I say method signature I am not talking about return type of the method, for example if
two methods have same name, same parameters and have different return type, then this is not
a valid method overloading example. This will throw compilation error.


Dynamic Polymorphism
--------------------
It is also known as Dynamic Method Dispatch. Dynamic polymorphism is a process in which a 
call to an overridden method is resolved at runtime rather, thats why it is called runtime 
polymorphism.


Example

class Animal {
   public void animalSound(){
	System.out.println("Default Sound");
   }
}


public class Dog extends Animal {
   public void animalSound(){
	System.out.println("Woof");
   }
   public static void main(String args[]){
	Animal obj = new Dog();
	obj.animalSound();
   }
}


Output:
Woof


Since both the classes, child class and parent class have the same method animalSound.
Which of the method will be called is determined at runtime by JVM.

Few more overriding examples:

Animal obj = new Animal();
obj.animalSound();
// This would call the Animal class method

Dog obj = new Dog();
obj.animalSound();
// This would call the Dog class method

Animal obj = new Dog();
obj.animalSound();
// This would call the Dog class method

IS-A & HAS-A Relationships
A Car IS-A Vehicle and HAS-A License then the code would look like this:


public class Vehicle {}
public class Car extends Vehicle{
   private License myCarLicense;
}

Abstract Class and methods in OOPs Concepts
Abstract method:

1) A method that is declared but not defined. Only method signature no body.
2) Declared using the abstract keyword
3) Example :
abstract public void playInstrument();

5) Used to put some kind of compulsion on the class who inherits the class has abstract 
methods. The class that inherits must provide the implementation of all the abstract methods 
of parent class else declare the subclass as abstract.

6) These cannot be abstract

Constructors
Static methods
Private methods
Methods that are declared “final”
Abstract Class

An abstract class outlines the methods but not necessarily implements all the methods.

abstract class A {
   abstract void myMethod();
   void anotherMethod() {
      // Does something
   }
}

Note 1: There can be some scenarios where it is difficult to implement all the methods in 
the base class. In such scenarios one can define the base class as an abstract class which 
signifies that this base class is a special kind of class which is not complete on its own.
A class derived from the abstract base class must implement those methods that are not 
implemented(means they are abstract) in the abstract class.


Note 2: Abstract class cannot be instantiated which means you cannot create the object of 
abstract class. To use this class, you need to create another class that extends this 
abstract class provides the implementation of abstract methods, then you can use the object
of that child class to call non-abstract parent class methods as well as implemented 
methods(those that were abstract in parent but implemented in child class).

Note 3: If a child does not implement all the abstract methods of parent class(the abstract 
class), then the child class must need to be declared abstract.


Example of Abstract class and Methods

Here we have an abstract class Animal that has an abstract method animalSound(), since the 
animal sound differs from one animal to another, there is no point in giving the 
implementation to this method as every child class must override this method to give its own
implementation details. That’s why we made it abstract.
Now each animal must have a sound, by making this method abstract we made it compulsory to 
the child class to give implementation details to this method. This way we ensures that every
animal has a sound.


// abstract class

abstract class Animal {
   // abstract method
   public abstract void animalSound();
}

public class Dog extends Animal {
   public void animalSound() {
	System.out.println("Woof");
   }

   public static void main(String args[]){
	Animal obj = new Dog();
	obj.animalSound();
   }
}

Output:
Woof


Interfaces in Java

An interface is a blueprint of a class, which can be declared by using interface keyword. 
Interfaces can contain only constants and abstract methods (methods with only signatures no 
body).Like abstract classes, Interfaces cannot be instantiated, they can only be implemented 
by classes or extended by other interfaces. Interface is a common way to achieve full 
abstraction in Java.


Note:
Java does not support Multiple Inheritance, however a class can implement more than one 
interfaces
Interface is similar to an abstract class but it contains only abstract methods.
Interfaces are created by using interface keyword instead of the keyword class
We use implements keyword while implementing an interface(similar to extending a class with 
extends keyword)

Interface: Syntax
class ClassName extends Superclass implements Interface1, Interface2, ....


Example of Interface:

Class Teacher {
    private String tname;
    private double tsalary;
    private String mainsubject;
    public String getName(){
        return this.tname;
    }
    public String setName(String Value){
        this.tname = value
    }
   // getter setter for salary and subject
}

Note:
All methods in an interface are implicitly public and abstract. Using the keyword abstract 
before each method is optional.
An interface may contain final variables.
A class can extend only one other class, but it can implement any number of interfaces.
When a class implements an interface it has to give the definition of all the abstract methods of interface, else it can be declared as abstract class
An interface reference can point to objects of its implementing classes.
Generalization and Specialization:
In order to implement the concept of inheritance in an OOPs, one has to first identify the 
similarities among different classes so as to come up with the base class.

This process of identifying the similarities among different classes is called Generalization. Generalization is the process of extracting shared characteristics from two or more classes, and combining them into a generalized superclass. Shared characteristics can be attributes or methods.

In contrast to generalization, specialization means creating new subclasses from an existing class. If it turns out that certain attributes or methods only apply to some of the objects of the class, a subclass can be created.

Access Specifiers
Well, you must have seen public, private keyword in the examples I have shared above. They 
are called access specifiers as they decide the scope of a data member, method or class.

There are four types of access specifiers in java:
public: Accessible to all. Other objects can also access this member variable or function.
private: Not accessible by other objects. Private members can be accessed only by the methods
in the same class. Object accessible only in class in which they are declared.
protected: The scope of a protected variable is within the class which declares it and in 
the class which inherits from the class (Scope is class and subclass).
Default: Scope is Package Level. We do not need to explicitly mention default as when we do 
not mention any access specifier it is considered as default.

What will we learn in the next tutorials on OOPs Concepts
Although we have covered almost all the OOPs concepts here, but whatever we have learned in 
this guide is in brief, these topics are wide and there is so much scope to learn these 
topics in detail with the help of examples. Thats why I have covered each and every topic 
in detail along with examples and diagrams in the next tutorials.
How can you read the next tutorials in a sequential manner? There are couple of ways to do 
it – 1) Tutorial links are provided in the left sidebar, go though them in the given sequence.
2) Go to the main java tutorial page that has all the links to the tutorials in the sequential manner.
If you find any difficulty understanding these OOPs Concepts then drop a comment below and I 
will get back to you as soon as possible.


Constructors in Java – A complete study!!
BY CHAITANYA SINGH | FILED UNDER: OOPS CONCEPT

Constructor is a block of code that initializes the newly created object. 
A constructor resembles an instance method in java but it’s not a method as it doesn’t have
a return type. In short constructor and method are different(More on this at the end of this 
guide). People often refer constructor as special type of method in Java.

Constructor has same name as the class and looks like this in a java code.

public class MyClass {
   // This is the constructor
   MyClass() {
   }
   ..
}

Note that the constructor name matches with the class name and it doesn’t have a return type.

How does a constructor work
To understand the working of constructor, lets take an example. lets say we have a class MyClass.
When we create the object of MyClass like this:

MyClass obj = new MyClass()
The new keyword here creates the object of class MyClass and invokes the constructor to 
initialize this newly created object.

You may get a little lost here as I have not shown you any initialization example, lets 
have a look at the code below:

A simple constructor program in java
Here we have created an object obj of class Hello and then we displayed the instance 
variable name of the object. As you can see that the output is BeginnersBook.com which is 
what we have passed to the name during initialization in constructor. This shows that when 
we created the object obj the constructor got invoked. In this example we have used this 
keyword, which refers to the current object, object obj in this example. We will cover this 
keyword in detail in the next tutorial.

public class Hello {
   String name;
   // Constructor
   Hello(){
      this.name = "BeginnersBook.com";
   }
   public static void main(String[] args) {
      Hello obj = new Hello();
      System.out.println(obj.name);
   }
}

Output:
BeginnersBook.com

     public class MyClass {
         // Constructor
         MyClass() {
             System.out.println("BeginnersBook.com")
         }
         public static void main(String args[]) {
             MyClass obj = new MyClass();
         }
     }

Types of Constructors

1. Default 
2. No-arg constructor
3. Parameterized

Default constructor
If you do not implement any constructor in your class, Java compiler inserts a default 
constructor into your code on your behalf. This constructor is known as default constructor.
You would not find it in your source code(the java file) as it would be inserted into the 
code during compilation and exists in .class file. 

This process is shown in the diagram below:

no-arg constructor:
Constructor with no arguments is known as no-arg constructor. The signature is same as default constructor, however body can have any code unlike default constructor where the body of the constructor is empty.

Although you may see some people claim that that default and no-arg constructor is same but in fact they are not, even if you write public Demo() { } in your class Demo it cannot be called default constructor since you have written the code of it.

Example: no-arg constructor

class Demo
{
     public Demo()
     {
         System.out.println("This is a no argument constructor");
     }
     public static void main(String args[]) {
    	 new Demo();
     }
}

Output:
This is a no argument constructor

Parameterized constructor
Constructor with arguments(or you can say parameters) is known as Parameterized constructor.

Example: parameterized constructor
In this example we have a parameterized constructor with two parameters id and name. 
While creating the objects obj1 and obj2 I have passed two arguments so that this constructor
gets invoked after creation of obj1 and obj2.


public class Employee {
   int empId;  
   String empName;  
	    
   // parameterized constructor with two parameters
   
   Employee(int id, String name){  
       this.empId = id;  
       this.empName = name;  
   }  
   void info(){
        System.out.println("Id: "+empId+ "Name: "+empName);
   }  
	   
   public static void main(String args[]){  
	Employee obj1 = new Employee(10245,"Chaitanya");  
	Employee obj2 = new Employee(92232,"Negan");  
	obj1.info();  
	obj2.info();  
   }  
}

Output:
Id: 10245 Name: Chaitanya
Id: 92232 Name: Negan


Example2: parameterized constructor
In this example, we have two constructors, a default constructor and a parameterized 
constructor. When we do not pass any parameter while creating the object using new keyword 
then default constructor is invoked, however when you pass a parameter then parameterized 
constructor that matches with the passed parameters list gets invoked.


class Example2
{
      private int var;
      // default constructor
      public Example2()
      {
             this.var = 10;
      }
      // parameterized constructor
      public Example2(int num)
      {
             this.var = num;
      }
      public int getValue()
      {
              return var;
      }
      public static void main(String args[])
      {
              Example2 obj = new Example2();
              Example2 obj2 = new Example2(100);
              System.out.println("var is: "+obj.getValue());
              System.out.println("var is: "+obj2.getValue());
      }
}

Output:
var is: 10
var is: 100

What if you implement only parameterized constructor in class

class Example3
{
      private int var;
      public Example3(int num)
      {
             var=num;
      }
      public int getValue()
      {
              return var;
      }
      public static void main(String args[])
      {
              Example3 myobj = new Example3();
              System.out.println("value of var is: "+myobj.getValue());
      }
}

Output: It will throw a compilation error. The reason is, 
the statement Example3 myobj = new Example3() is invoking a default constructor which 
we don’t have in our program. when you don’t implement any constructor in your class, 
compiler inserts the default constructor into your code, however when you implement any 
constructor (in above example I have implemented parameterized constructor with int parameter),
then you don’t receive the default constructor by compiler into your code.

If we remove the parameterized constructor from the above code then the program would run 
fine, because then compiler would insert the default constructor into your code.

Constructor Chaining
When A constructor calls another constructor of same class then this is called constructor 
chaining. Read more about it here.

Super()
Whenever a child class constructor gets invoked it implicitly invokes the constructor of 
parent class. You can also say that the compiler inserts a super(); statement at the 
beginning of child class constructor.

class MyParentClass {
   MyParentClass(){
	System.out.println("MyParentClass Constructor");
   }
}
class MyChildClass extends MyParentClass {
   MyChildClass() {
	System.out.println("MyChildClass Constructor");
   }
   public static void main(String args[]) {
	new MyChildClass();
   }
}

Output:
MyParentClass Constructor
MyChildClass Constructor
Read more about super keyword here.

Constructor Overloading
Constructor overloading is a concept of having more than one constructor with different 
parameters list, in such a way so that each constructor performs a different task.

Java Copy Constructor
A copy constructor is used for copying the values of one object to another object.

class JavaExample {  
   String web; 
   JavaExample(String w) {  
	web = w;
   }  

   /* This is the Copy Constructor, it 
    * copies the values of one object
    * to the another object (the object
    * that invokes this constructor)
    */

   JavaExample(JavaExample je) {  
	web = je.web; 
   }

   void disp() {
	System.out.println("Website: "+web);
   }  

   public static void main(String args[]) {  
	JavaExample obj1 = new JavaExample("BeginnersBook");  
		
	/* Passing the object as an argument to the constructor
	 * This will invoke the copy constructor
	 */
	JavaExample obj2 = new JavaExample(obj1);  
	obj1.disp();  
	obj2.disp();  
   }  
}

Output:
Website: BeginnersBook
Website: BeginnersBook


Quick Recap
Every class has a constructor whether it’s a normal class or a abstract class.
Constructors are not methods and they don’t have any return type.
Constructor name should match with class name .
Constructor can use any access specifier, they can be declared as private also. 
Private constructors are possible in java but there scope is within the class only.
Like constructors method can also have name same as class name, but still they have return 
type, though which we can identify them that they are methods not constructors.
If you don’t implement any constructor within the class, compiler will do it for.
this() and super() should be the first statement in the constructor code. If you don’t mention
them, compiler does it for you accordingly.
Constructor overloading is possible but overriding is not possible. Which means we can have 
overloaded constructor in our class but we can’t override a constructor.
Constructors can not be inherited.
If Super class doesn’t have a no-arg(default) constructor then compiler would not insert a 
default constructor in child class as it does in normal scenario.
Interfaces do not have constructors.
Abstract class can have constructor and it gets invoked when a class, which implements 
interface, is instantiated. (i.e. object creation of concrete class).
A constructor can also invoke another constructor of the same class – By using this(). 
If you want to invoke a parameterized constructor then do it like this: this(parameter list).

More on Constructor:

Private constructor
Can we have static constructors in Java?
Difference between Constructor and Method
I know I should have mentioned it at the beginning of this guide but I wanted to cover 
everything in a flow. Hope you don’t mind :)

The purpose of constructor is to initialize the object of a class while the purpose of a 
method is to perform a task by executing java code.
Constructors cannot be abstract, final, static and synchronised while methods can be.
Constructors do not have return types while methods do.


Static keyword can be used with class, variable, method and block. Static members belong to 
the class instead of a specific instance, this means if you make a member static, you can 
access it without object. Let’s take an example to understand this:

Here we have a static method myMethod(), we can call this method without any object because 
when we make a member static it becomes class level. If we remove the static keyword and 
make it non-static then we must need to create an object of the class in order to call it.

Static members are common for all the instances(objects) of the class but non-static members 
are separate for each instance of class.

class SimpleStaticExample
{
    // This is a static method
    static void myMethod()
    {
        System.out.println("myMethod");
    }
 
    public static void main(String[] args)
    {
          /* You can see that we are calling this
           * method without creating any object. 
           */
           myMethod();
    }
}

Output:
myMethod

Static Block
Static block is used for initializing the static variables.This block gets executed when the 
class is loaded in the memory. A class can have multiple Static blocks, which will execute in the same sequence in which they have been written into the program.

Example 1: Single static block
As you can see that both the static variables were intialized before we accessed them in the 
main method.

class JavaExample {
   static int num;
   static String mystr;
   static {
      num = 97;
      mystr = "Static keyword in Java";
   }

   public static void main(String args[])
   {
      System.out.println("Value of num: "+num);
      System.out.println("Value of mystr: "+mystr);
   }
}

Output:
Value of num: 97
Value of mystr: Static keyword in Java


Example 2: Multiple Static blocks

Lets see how multiple static blocks work in Java. They execute in the given order which means
the first static block executes before second static block. That’s the reason, values 
initialized by first block are overwritten by second block.


class JavaExample2 {
   static int num;
   static String mystr;
   // First Static block
   static {
      System.out.println("Static Block 1");
      num = 68;
      mystr = "Block1";
  } 
  //Second static block
  static{
      System.out.println("Static Block 2");
      num = 98;
      mystr = "Block2";
  }
  public static void main(String args[])
  {
      System.out.println("Value of num: "+num);
      System.out.println("Value of mystr: "+mystr);
   }
}

Output:
Static Block 1
Static Block 2
Value of num: 98
Value of mystr: Block2


Java Static Variables

A static variable is common to all the instances (or objects) of the class because it is a 
class level variable. In other words you can say that only a single copy of static variable 
is created and shared among all the instances of the class. Memory allocation for such 
variables only happens once when the class is loaded in the memory.

Few Important Points:

Static variables are also known as Class Variables.
Unlike non-static variables, such variables can be accessed directly in static and 
non-static methods.

Example 1: Static variables can be accessed directly in Static method
Here we have a static method disp() and two static variables var1 and var2. 
Both the variables are accessed directly in the static method.

class JavaExample3 {
  static int var1;
  static String var2;
  // This is a Static Method
  static void disp() {
      System.out.println("Var1 is: "+var1);
      System.out.println("Var2 is: "+var2);
  }
  public static void main(String args[]) {
      disp();
  }
}

Output:
Var1 is: 0
Var2 is: null

Example 2: Static variables are shared among all the instances of class
In this example, String variable is non-static and integer variable is Static. 
As you can see in the output that the non-static variable is different for both the objects
but the static variable is shared among them, thats the reason the changes made to the static
variable by object ob2 reflects in both the objects.

class JavaExample {
   // Static integer variable
   static int var1 = 77; 
   // non-static string variable
   String var2;

   public static void main(String args[]) {
	JavaExample ob1 = new JavaExample();
	JavaExample ob2 = new JavaExample();

	/* static variables can be accessed directly without
	 * any instances. Just to demonstrate that static variables
	 * are shared, I am accessing them using objects so that 
	 * we can check that the changes made to static variables
	 * by one object, reflects when we access them using other
	 * objects
	 */
    // Assigning the value to static variable using object ob1

	ob1.var1=88;
	ob1.var2="I'm Object1";

    /* This will overwrite the value of var1 because var1 has a single 
     * copy shared among both the objects.
     */
    
    ob2.var1=99;
	ob2.var2="I'm Object2";
	
    System.out.println("ob1 integer:"+ob1.var1);
	System.out.println("ob1 String:"+ob1.var2);
	System.out.println("ob2 integer:"+ob2.var1);
	System.out.println("ob2 STring:"+ob2.var2);
   }
}


Output:
ob1 integer:99
ob1 String:I'm Object1
ob2 integer:99
ob2 STring:I'm Object2

For more details on refer: Java – static variable

Java Static Methods
Static Methods can access class variables(static variables) without using object(instance) of
the class, however non-static methods and non-static variables can only be accessed using objects.

Static methods can be accessed directly in static and non-static methods.

Syntax:

Static keyword followed by return type, followed by method name.

static return_type method_name();

Example 1: static method main is accessing static variables without object

class JavaExample {
   static int i = 10;
   static String s = "Beginnersbook";
   // This is a static method
   public static void main(String args[]) {
       System.out.println("i:"+i);
       System.out.println("s:"+s);
   }
}

Output:
i:10
s:Beginnersbook

Example 2: Static method accessed directly in static and non-static method

class JavaExample {
  static int i = 100;
  static String s = "Beginnersbook";
  
  // Static method
  static void display() {
     System.out.println("i:"+i);
     System.out.println("i:"+s);
  }

  // non-static method
  void funcn() {
    // Static method called in non-static method
    display();
  }

  // static method
  public static void main(String args[]) {
	JavaExample obj = new JavaExample();
	// You need to have object to call this non-static method
	obj.funcn();
	  
    // Static method called in another static method
    display();
   }
}

Output:
i:100
i:Beginnersbook
i:100
i:Beginnersbook

Read more: Static Method vs non-static Method in Java

Static Class
A class can be made static only if it is a nested class.

Nested static class doesn’t need reference of Outer class
A static class cannot access non-static members of the Outer class
We will see these two points with the help of an example:


Static class Example
class JavaExample {
   private static String str = "BeginnersBook";

   // Static class
   static class MyNestedClass{
	
   // Non-static method
	public void disp() {
	   /* If you make the str variable of outer class
	    * non-static then you will get compilation error
	    * because: a nested static class cannot access non-
	    * static members of the outer class.
	    */
	   System.out.println(str); 
	}
   }
   public static void main(String args[]) {
    
    /* To create instance of nested class we didn't need the outer
	  * class instance but for a regular nested class you would need 
	  * to create an instance of outer class first
     */
	
    JavaExample.MyNestedClass obj = new JavaExample.MyNestedClass();
    obj.disp();
   
   }
}

Output:
BeginnersBook


The process by which one class acquires the properties(data members) and functionalities
(methods) of another class is called inheritance. The aim of inheritance is to provide the 
reusability of code so that a class has to write only the unique features and rest of the 
common properties and functionalities can be extended from the another class.

Child Class:
The class that extends the features of another class is known as child class, sub class or 
derived class.

Parent Class:
The class whose properties and functionalities are used(inherited) by another class is
known as parent class, super class or Base class.

Inheritance is a process of defining a new class based on an existing class by extending its 
common data members and methods.
Inheritance allows us to reuse of code, it improves reusability in your java application.
Note: The biggest advantage of Inheritance is that the code that is already present in base 
class need not be rewritten in the child class.

This means that the data members(instance variables) and methods of the parent class can be 
used in the child class as.

If you are finding it difficult to understand what is class and object then refer the guide 
that I have shared on object oriented programming: OOPs Concepts

Lets back to the topic:

Syntax: Inheritance in Java
To inherit a class we use extends keyword. Here class XYZ is child class and class ABC is 
parent class. The class XYZ is inheriting the properties and methods of ABC class.

class XYZ extends ABC {

}


Inheritance Example

In this example, we have a base class Teacher and a sub class PhysicsTeacher. Since class 
PhysicsTeacher extends the designation and college properties and work() method from base 
class, we need not to declare these properties and method in sub class.
Here we have collegeName, designation and work() method which are common to all the teachers 
so we have declared them in the base class, this way the child classes like MathTeacher, 
MusicTeacher and PhysicsTeacher do not need to write this code and can be used directly from 
base class.

class Teacher {
   String designation = "Teacher";
   String collegeName = "Beginnersbook";
   void does(){
	System.out.println("Teaching");
   }
}

public class PhysicsTeacher extends Teacher {
   String mainSubject = "Physics";
   public static void main(String args[]) {
	 PhysicsTeacher obj = new PhysicsTeacher();
	 System.out.println(obj.collegeName);
	 System.out.println(obj.designation);
	 System.out.println(obj.mainSubject);
	 obj.does();
   }
}


Output:
Beginnersbook
Teacher
Physics
Teaching


Based on the above example we can say that PhysicsTeacher IS-A Teacher. This means that a 
child class has IS-A relationship with the parent class. This is inheritance is known as IS-A
relationship between child and parent class


Note:
The derived class inherits all the members and methods that are declared as public or 
protected. If the members or methods of super class are declared as private then the derived
class cannot use them directly. The private members can be accessed only in its own class. 
Such private members can only be accessed using public or protected getter and setter methods
of super class as shown in the example below.


class Teacher {
   private String designation = "Teacher";
   private String collegeName = "Beginnersbook";
   public String getDesignation() {
	return designation;
   }
   protected void setDesignation(String designation) {
	this.designation = designation;
   }
   protected String getCollegeName() {
	return collegeName;
   }
   protected void setCollegeName(String collegeName) {
	this.collegeName = collegeName;
   }
   void does(){
	System.out.println("Teaching");
   }
}

public class JavaExample extends Teacher {
   String mainSubject = "Physics";
   public static void main(String args[]){
	JavaExample obj = new JavaExample();
	/* Note: we are not accessing the data members 
	 * directly we are using public getter method 
	 * to access the private members of parent class
	 */
	System.out.println(obj.getCollegeName());
	System.out.println(obj.getDesignation());
	System.out.println(obj.mainSubject);
	obj.does();
   }
}

The output is:

Beginnersbook
Teacher
Physics
Teaching


The important point to note in the above example is that the child class is able to access 
the private members of parent class through protected methods of parent class. When we make 
a instance variable(data member) or method protected, this means that they are accessible 
only in the class itself and in child class. These public, protected, private etc. are all 
access specifiers and we will discuss them in the coming tutorials.

Types of inheritance
To learn types of inheritance in detail, refer: Types of Inheritance in Java.
Single Inheritance: refers to a child and parent class relationship where a class extends the
another class.


              ____
             |  A |
             |____| 
                ^
                |  
                |
             ______ 
             |  B |
             |____| 
 
        Single Inheritance


Multilevel inheritance: refers to a child and parent class relationship where a class extends
the child class. For example class C extends class B and class B extends class A.

             ______
             |  A |
             |____| 
                ^
                |  
                |
             ______ 
             |  B |
             |____| 
               ^
               |
               |
             ______ 
             | C  |
             |____| 

       Multilevel Inheritance

Hierarchical inheritance: Refers to a child and parent class relationship where more than one
classes extends the same class. For example, classes B, C & D extends the same class A.

             ______ 
             |  A |
             |____| 
              ^ ^ ^
             _| | |__    
            /   |     \
           B    C     D  



Multiple Inheritance: refers to the concept of one class extending more than one classes, 
which means a child class has two parent classes. 
For example class C extends both classes A and B. Java doesn’t support multiple inheritance, 
read more about it


               A         B
               ^         ^
               |__    __ |
                 |   | 
                   C

                
Hybrid inheritance: Combination of more than one types of inheritance in a single program. 
For example class A & B extends class C and another class D extends class A then this is a 
hybrid inheritance example because it is a combination of single and hierarchical inheritance.

Constructors and Inheritance
constructor of sub class is invoked when we create the object of subclass, it by default 
invokes the default constructor of super class. Hence, in inheritance the objects are constructed top-down. The superclass constructor can be called explicitly using the super keyword, but it should be first statement in a constructor. The super keyword refers to the superclass, immediately above of the calling class in the hierarchy. The use of multiple super keywords to access an ancestor class other than the direct parent is not permitted.

class ParentClass {
   // Parent class constructor
   ParentClass() {
	System.out.println("Constructor of Parent");
   }
}

class JavaExample extends ParentClass {
   JavaExample() {
	/* It by default invokes the constructor of parent class
	 * You can use super() to call the constructor of parent.
	 * It should be the first statement in the child class
	 * constructor, you can also call the parameterized constructor
	 * of parent class by using super like this: super(10), now
	 * this will invoke the parameterized constructor of int arg
	 */
	System.out.println("Constructor of Child");
   }
   public static void main(String args[]){
	//Creating the object of child class
	new JavaExample();
   }
}

Output:
Constructor of Parent
Constructor of Child
Inheritance and Method Overriding

When we declare the same method in child class which is already present in the parent class 
the this is called method overriding. In this case when we call the method from child class 
object, the child class version of the method is called. However we can call the parent class
method using super keyword as I have shown in the example below:


class ParentClass {
   // Parent class constructor
   ParentClass() {
	System.out.println("Constructor of Parent");
   }
   void disp() {
	System.out.println("Parent Method");
   }
}

class JavaExample extends ParentClass {
   JavaExample() {
	System.out.println("Constructor of Child");
   }
   void disp(){
	System.out.println("Child Method");
        // Calling the disp() method of parent class
	super.disp();
   }
   public static void main(String args[]) {
	// Creating the object of child class
	JavaExample obj = new JavaExample();
	obj.disp();
   }
}

The output is :
Constructor of Parent
Constructor of Child
Child Method
Parent Method

